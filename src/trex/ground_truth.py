"""Generates a ground truth phylogenetic tree and sequences using JAX."""

from functools import partial

import jax
import jax.numpy as jnp
from jax import jit, random
from jaxtyping import PRNGKeyArray

from trex.utils.types import (
  EvoSequence,
  EvoSequencePyTree,
  PhylogeneticTree,
)


@partial(jit, static_argnames=("n_states", "n_mutations"))
def mutate(
  key: PRNGKeyArray,
  sequence: EvoSequence,
  n_states: int,
  n_mutations: int,
) -> EvoSequence:
  """Apply random mutations to a population of nucleotide sequences.

  Args:
      key: JAX PRNG key.
      sequence: JAX array of nucleotide sequences
                  (shape: (n, nuc_len)).
      n_states: Number of states. e.g., nucleotide types (4 for A, C, G, T).
      n_mutations: Number of mutations to apply to the sequence.

  Returns: JAX array of mutated nucleotide sequences.

  """
  key_mutate, key_offsets = random.split(key)
  mutation_mask = jnp.zeros(sequence.shape[0], dtype=bool)
  if n_mutations > 0:
    mutations = random.choice(
      key_mutate,
      sequence.shape[0],
      shape=(n_mutations,),
      replace=False,
    )
    mutation_mask = mutation_mask.at[mutations].set(True)
  offsets = random.randint(key_offsets, shape=sequence.shape, minval=1, maxval=n_states)
  proposed_mutations = (sequence + offsets) % n_states
  mutated_sequences = jnp.where(mutation_mask, proposed_mutations, sequence)
  return mutated_sequences.astype(jnp.int8)


def _generate_tree_recursive(  # noqa: PLR0913
  key: PRNGKeyArray,
  parent_seq: EvoSequence,
  current_depth: int,
  target_depth: int,
  n_states: int,
  n_mutations: int,
) -> EvoSequencePyTree:
  """Recursively generates a binary tree of sequences by applying mutations.

  This is a pure function that avoids side effects by returning the generated
  sequences at each level of the recursion.

  Args:
      key: JAX random key.
      parent_seq: The sequence of the parent node.
      current_depth: The current depth in the tree.
      target_depth: The maximum depth of the tree to generate.
      n_states: The size of the alphabet.
      n_mutations: The number of mutations to apply at each split.

  Returns:
      A tuple containing:
      - A list of all leaf sequences generated from this node.
      - A list of lists, where each inner list contains all sequences at a
        given depth generated from this node.

  """
  if current_depth > target_depth:
    return parent_seq

  mutation_key1, mutation_key2, tree_key1, tree_key2 = random.split(key, 4)

  child_seqs = jax.vmap(mutate, in_axes=(0, None, None, None))(
    jnp.array([mutation_key1, mutation_key2]),
    parent_seq,
    n_states,
    n_mutations,
  )

  # Recursively generate the subtrees for each child
  child_trees = jax.vmap(
    _generate_tree_recursive,
    in_axes=(0, 0, None, None, None, None),
  )(
    jnp.array([tree_key1, tree_key2]),
    child_seqs,
    current_depth + 1,
    target_depth,
    n_states,
    n_mutations,
  )

  # Return the parent sequence and its two child subtrees as a tuple
  return (parent_seq, child_trees[0], child_trees[1])


def generate_groundtruth(
  n_leaves: int,
  n_states: int,
  n_mutations: int,
  seq_length: int,
  seed: int = 42,
) -> PhylogeneticTree:
  """Generate a ground truth phylogenetic tree example.

  This function creates a binary tree of sequences, where child sequences are
  generated by mutating their parents. It returns the leaf sequences (masked),
  the full set of true sequences (leaves and ancestors), and the tree
  structure as an adjacency matrix.

  Args:
      metadata: Dictionary containing specifications for the tree:
          "n_leaves": The number of leaf nodes in the tree (must be a power of 2).
          "seq_length": The length of each sequence.
          "n_states": The size of the alphabet (e.g., 4 for DNA).
          "n_mutations": The number of mutations to apply at each split.
      seed: The random seed for reproducibility.

  Returns:
      A tuple containing:
      - masked_main: The leaf sequences, with ancestor nodes masked (zeroed).
      - true_main: The complete set of true sequences, including ancestors.
      - tree: The adjacency matrix representing the parent-child relationships.

  """
  key = random.PRNGKey(seed)

  if not (n_leaves > 0 and (n_leaves & (n_leaves - 1) == 0)):
    msg = "n_leaves must be a power of 2."
    raise ValueError(msg)

  depth = int(jnp.log2(n_leaves))
  root_seq = jnp.zeros(seq_length, dtype=jnp.int8)
  n_ancestors = n_leaves - 1
  n_all = n_leaves + n_ancestors

  all_sequences = jnp.zeros((n_all, seq_length), dtype=jnp.int8)
  all_sequences = all_sequences.at[n_all - 1].set(root_seq)

  keys = random.split(key, n_ancestors)

  def _generate_children_for_parent(i: jax.Array, all_seqs: jax.Array) -> jax.Array:
    parent_idx = n_all - 1 - i
    parent_seq = all_seqs[parent_idx]
    p_i = parent_idx - n_leaves
    child1_idx = 2 * p_i
    child2_idx = 2 * p_i + 1

    child_seqs = jax.vmap(mutate, in_axes=(0, None, None, None))(
      random.split(keys[i], 2),
      parent_seq,
      n_states,
      n_mutations,
    )

    all_seqs = all_seqs.at[child1_idx].set(child_seqs[0])
    return all_seqs.at[child2_idx].set(child_seqs[1])

  true_main = jax.lax.fori_loop(0, n_ancestors, _generate_children_for_parent, all_sequences)

  leaf_sequences = true_main[:n_leaves]
  masked_main_list = list(leaf_sequences) + ([jnp.zeros_like(root_seq)] * n_ancestors)
  masked_main = jnp.stack(masked_main_list)

  n_all: int = n_leaves + n_ancestors

  def add_edges(
    tree: jax.Array,
    i: jax.Array,
  ) -> tuple[jax.Array, None]:
    child_idx: jax.Array = 2 * i
    parent_idx: jax.Array = n_leaves + i
    tree = tree.at[child_idx, parent_idx].set(1)
    tree = tree.at[child_idx + 1, parent_idx].set(1)
    return tree, None

  tree: jax.Array = jnp.zeros((n_all, n_all), dtype=jax.numpy.float32)
  tree, _ = jax.lax.scan(add_edges, tree, jnp.arange(n_ancestors))

  return PhylogeneticTree(
    masked_sequences=masked_main.astype(jnp.bfloat16),
    all_sequences=true_main.astype(jnp.bfloat16),
    adjacency=tree.astype(jnp.bfloat16),
  )
